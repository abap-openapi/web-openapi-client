"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkweb"] = self["webpackChunkweb"] || []).push([["output_zcl_oapi_json_clas_locals_mjs"],{

/***/ "../output/zcl_oapi_json.clas.locals.mjs":
/*!***********************************************!*\
  !*** ../output/zcl_oapi_json.clas.locals.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_stack\": () => (/* binding */ lcl_stack),\n/* harmony export */   \"lcl_parser\": () => (/* binding */ lcl_parser)\n/* harmony export */ });\nconst {cx_root} = await __webpack_require__.e(/*! import() */ \"output_cx_root_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"../output/cx_root.clas.mjs\"));\n// zcl_oapi_json.clas.locals_def.abap\n// zcl_oapi_json.clas.locals_imp.abap\nconst constant_0 = new abap.types.Integer().set(0);\nconst constant_1 = new abap.types.Integer().set(1);\nclass lcl_stack {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_data = new abap.types.Table(new abap.types.Structure({name: new abap.types.String(), is_array: new abap.types.Character({qualifiedName: \"ABAP_BOOL\"}), array_index: new abap.types.Integer()}, \"lcl_stack=>ty_data\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    return this;\n  }\n  async push(INPUT) {\n    let iv_name = new abap.types.String();\n    if (INPUT && INPUT.iv_name) {iv_name.set(INPUT.iv_name);}\n    let iv_type = new abap.types.String();\n    if (INPUT && INPUT.iv_type) {iv_type.set(INPUT.iv_type);}\n    let ls_data = new abap.types.Structure({name: new abap.types.String(), is_array: new abap.types.Character({qualifiedName: \"ABAP_BOOL\"}), array_index: new abap.types.Integer()}, \"lcl_stack=>ty_data\");\n    ls_data.get().name.set(iv_name);\n    ls_data.get().is_array.set(abap.builtin.boolc(abap.compare.eq(iv_type, new abap.types.Character({length: 5}).set('array'))));\n    abap.statements.append({source: ls_data, target: this.mt_data});\n  }\n  async is_array() {\n    let rv_array = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    let lv_index = new abap.types.Integer();\n    let ls_data = new abap.types.Structure({name: new abap.types.String(), is_array: new abap.types.Character({qualifiedName: \"ABAP_BOOL\"}), array_index: new abap.types.Integer()}, \"lcl_stack=>ty_data\");\n    lv_index.set(abap.builtin.lines({val: this.mt_data}));\n    abap.statements.readTable(this.mt_data,{index: lv_index,into: ls_data});\n    rv_array.set(ls_data.get().is_array);\n    return rv_array;\n  }\n  async get_and_increase_index() {\n    let rv_index = new abap.types.String();\n    let lv_index = new abap.types.Integer();\n    let fs_ls_data_ = new abap.types.FieldSymbol();\n    lv_index.set(abap.builtin.lines({val: this.mt_data}));\n    abap.statements.readTable(this.mt_data,{index: lv_index,assigning: fs_ls_data_});\n    if (abap.compare.eq(abap.builtin.sy.get().subrc, constant_0)) {\n      fs_ls_data_.get().array_index.set(abap.operators.add(fs_ls_data_.get().array_index,constant_1));\n      rv_index.set(fs_ls_data_.get().array_index);\n      rv_index.set(abap.builtin.condense({val: rv_index}));\n    }\n    return rv_index;\n  }\n  async pop() {\n    let rv_name = new abap.types.String();\n    let lv_index = new abap.types.Integer();\n    let ls_data = new abap.types.Structure({name: new abap.types.String(), is_array: new abap.types.Character({qualifiedName: \"ABAP_BOOL\"}), array_index: new abap.types.Integer()}, \"lcl_stack=>ty_data\");\n    lv_index.set(abap.builtin.lines({val: this.mt_data}));\n    if (abap.compare.gt(lv_index, constant_0)) {\n      abap.statements.readTable(this.mt_data,{index: lv_index,into: ls_data});\n      rv_name.set(ls_data.get().name);\n      abap.statements.deleteInternal(this.mt_data,{index: lv_index});\n    }\n    return rv_name;\n  }\n  async get_full_name() {\n    let rv_path = new abap.types.String();\n    let ls_data = new abap.types.Structure({name: new abap.types.String(), is_array: new abap.types.Character({qualifiedName: \"ABAP_BOOL\"}), array_index: new abap.types.Integer()}, \"lcl_stack=>ty_data\");\n    for (const unique12 of abap.statements.loop(this.mt_data)) {\n      ls_data.set(unique12);\n      rv_path.set(abap.operators.concat(rv_path,ls_data.get().name));\n    }\n    return rv_path;\n  }\n}\nabap.Classes['CLAS-ZCL_OAPI_JSON-LCL_STACK'] = lcl_stack;\nclass lcl_parser {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n  async parse(INPUT) {\n    let rt_data = new abap.types.Table(new abap.types.Structure({parent: new abap.types.String(), name: new abap.types.String(), full_name: new abap.types.String(), value: new abap.types.String()}, \"ty_data\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"});\n    let li_next = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"});\n    let li_reader = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_READER\"});\n    let li_close = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_CLOSE_ELEMENT\"});\n    let li_open = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_OPEN_ELEMENT\"});\n    let lt_attributes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let li_attribute = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"});\n    let li_value = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_VALUE_NODE\"});\n    let lv_push = new abap.types.String();\n    let lv_name = new abap.types.String();\n    let lo_stack = new abap.types.ABAPObject({qualifiedName: \"LCL_STACK\"});\n    let ls_data = new abap.types.Structure({parent: new abap.types.String(), name: new abap.types.String(), full_name: new abap.types.String(), value: new abap.types.String()}, \"ty_data\");\n    let lv_index = new abap.types.Integer();\n    let lt_nodes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"}), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    lo_stack.set(await (new abap.Classes['CLAS-ZCL_OAPI_JSON-LCL_STACK']()).constructor_());\n    li_reader.set(await abap.Classes['CL_SXML_STRING_READER'].create({data: await abap.Classes['CL_ABAP_CODEPAGE'].convert_to({source: iv_json})}));\n    let unique13 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique13++);\n      li_node.set(await li_reader.get().if_sxml_reader$read_next_node());\n      if (abap.compare.initial(li_node)) {\n        break;\n      }\n      abap.statements.append({source: li_node, target: lt_nodes});\n    }\n    for (const unique14 of abap.statements.loop(lt_nodes)) {\n      li_node.set(unique14);\n      lv_index.set(abap.builtin.sy.get().tabix);\n      let unique15 = li_node.get().if_sxml_node$type;\n      if (abap.compare.eq(unique15, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {\n        await abap.statements.cast(li_open, li_node);\n        lt_attributes.set(await li_open.get().if_sxml_open_element$get_attributes());\n        abap.statements.readTable(lt_attributes,{index: constant_1,into: li_attribute});\n        if (abap.compare.eq(abap.builtin.sy.get().subrc, constant_0)) {\n          lv_push.set(await li_attribute.get().if_sxml_attribute$get_value());\n        } else if (abap.compare.eq(await lo_stack.get().is_array(), abap.builtin.abap_true)) {\n          lv_push.set(await lo_stack.get().get_and_increase_index());\n        }\n        if (abap.compare.initial(lv_push) === false) {\n          abap.statements.clear(ls_data);\n          ls_data.get().parent.set(await lo_stack.get().get_full_name());\n          ls_data.get().name.set(lv_push);\n          ls_data.get().full_name.set(abap.operators.concat(ls_data.get().parent,ls_data.get().name));\n          lv_index.set(abap.operators.add(lv_index,constant_1));\n          abap.statements.readTable(lt_nodes,{index: lv_index,into: li_next});\n          if (abap.compare.eq(abap.builtin.sy.get().subrc, constant_0) && abap.compare.eq(li_next.get().if_sxml_node$type, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value)) {\n            await abap.statements.cast(li_value, li_next);\n            ls_data.get().value.set(await li_value.get().if_sxml_value_node$get_value());\n          }\n          abap.statements.append({source: ls_data, target: rt_data});\n          await lo_stack.get().push({iv_name: lv_push, iv_type: li_open.get().if_sxml_open_element$qname.get().name});\n        }\n        if (abap.compare.eq(li_open.get().if_sxml_open_element$qname.get().name, new abap.types.Character({length: 6}).set('object')) || abap.compare.eq(li_open.get().if_sxml_open_element$qname.get().name, new abap.types.Character({length: 5}).set('array'))) {\n          abap.statements.clear(ls_data);\n          ls_data.get().parent.set(await lo_stack.get().get_full_name());\n          ls_data.get().name.set(new abap.types.Character({length: 1}).set('/'));\n          ls_data.get().full_name.set(abap.operators.concat(ls_data.get().parent,ls_data.get().name));\n          abap.statements.append({source: ls_data, target: rt_data});\n          await lo_stack.get().push({iv_name: new abap.types.Character({length: 1}).set('/'), iv_type: li_open.get().if_sxml_open_element$qname.get().name});\n        }\n      } else if (abap.compare.eq(unique15, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {\n        await abap.statements.cast(li_close, li_node);\n        lv_name.set(await lo_stack.get().pop());\n        if (abap.compare.eq(lv_name, new abap.types.Character({length: 1}).set('/'))) {\n          await lo_stack.get().pop();\n        }\n      }\n    }\n    return rt_data;\n  }\n}\nabap.Classes['CLAS-ZCL_OAPI_JSON-LCL_PARSER'] = lcl_parser;\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://web/../output/zcl_oapi_json.clas.locals.mjs?");

/***/ })

}]);