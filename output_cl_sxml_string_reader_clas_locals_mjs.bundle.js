"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkweb"] = self["webpackChunkweb"] || []).push([["output_cl_sxml_string_reader_clas_locals_mjs"],{

/***/ "../output/cl_sxml_string_reader.clas.locals.mjs":
/*!*******************************************************!*\
  !*** ../output/cl_sxml_string_reader.clas.locals.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_json_parser\": () => (/* binding */ lcl_json_parser),\n/* harmony export */   \"lcl_attribute\": () => (/* binding */ lcl_attribute),\n/* harmony export */   \"lcl_open_node\": () => (/* binding */ lcl_open_node),\n/* harmony export */   \"lcl_close_node\": () => (/* binding */ lcl_close_node),\n/* harmony export */   \"lcl_value_node\": () => (/* binding */ lcl_value_node),\n/* harmony export */   \"lcl_reader\": () => (/* binding */ lcl_reader)\n/* harmony export */ });\nconst {cx_root} = await __webpack_require__.e(/*! import() */ \"output_cx_root_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"../output/cx_root.clas.mjs\"));\n// cl_sxml_string_reader.clas.locals_imp.abap\nconst constant_1 = new abap.types.Integer().set(1);\nconst constant_2 = new abap.types.Integer().set(2);\nclass lcl_json_parser {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_nodes = new abap.types.Table(new abap.types.Structure({type: new abap.types.Integer(), name: new abap.types.String(), key: new abap.types.String(), value: new abap.types.String()}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    return this;\n  }\n  async parse(INPUT) {\n    let rt_nodes = new abap.types.Table(new abap.types.Structure({type: new abap.types.Integer(), name: new abap.types.String(), key: new abap.types.String(), value: new abap.types.String()}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    abap.statements.clear(this.mt_nodes);\n    await this.traverse({iv_json: iv_json});\n    rt_nodes.set(this.mt_nodes);\n    return rt_nodes;\n  }\n  async append(INPUT) {\n    let iv_type = new abap.types.Integer();\n    if (INPUT && INPUT.iv_type) {iv_type.set(INPUT.iv_type);}\n    let iv_name = new abap.types.String();\n    if (INPUT && INPUT.iv_name) {iv_name.set(INPUT.iv_name);}\n    let iv_key = new abap.types.String();\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let iv_value = new abap.types.String();\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\n    let ls_node = new abap.types.Structure({type: new abap.types.Integer(), name: new abap.types.String(), key: new abap.types.String(), value: new abap.types.String()}, \"lcl_json_parser=>ty_node\");\n    ls_node.get().type.set(iv_type);\n    ls_node.get().name.set(iv_name);\n    ls_node.get().key.set(iv_key);\n    ls_node.get().value.set(iv_value);\n    abap.statements.append({source: ls_node, target: this.mt_nodes});\n  }\n  async traverse(INPUT) {\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let iv_key = new abap.types.String();\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_type = new abap.types.String();\n    let parsed = JSON.parse(iv_json.get());\n    lv_type.set(Array.isArray(parsed) ? \"array\" : typeof parsed);\n    if (parsed === null) lv_type.set(\"null\");\n    let unique77 = lv_type;\n    if (abap.compare.eq(unique77, new abap.types.Character({length: 6}).set('object'))) {\n      await this.traverse_object({iv_json: iv_json, iv_key: iv_key});\n    } else if (abap.compare.eq(unique77, new abap.types.Character({length: 5}).set('array'))) {\n      await this.traverse_array({iv_json: iv_json, iv_key: iv_key});\n    } else if (abap.compare.eq(unique77, new abap.types.Character({length: 6}).set('string')) || abap.compare.eq(unique77, new abap.types.Character({length: 7}).set('boolean')) || abap.compare.eq(unique77, new abap.types.Character({length: 6}).set('number')) || abap.compare.eq(unique77, new abap.types.Character({length: 4}).set('null'))) {\n      await this.traverse_basic({iv_json: iv_json, iv_key: iv_key});\n    } else {\n      abap.statements.assert(abap.compare.eq(constant_2, new abap.types.Character({length: 4}).set('todo')));\n    }\n  }\n  async traverse_basic(INPUT) {\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let iv_key = new abap.types.String();\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_type = new abap.types.String();\n    let parsed = JSON.parse(iv_json.get());\n    lv_type.set(typeof parsed);\n    if (parsed === null) lv_type.set(\"null\");\n    let unique78 = lv_type;\n    if (abap.compare.eq(unique78, new abap.types.Character({length: 6}).set('string'))) {\n      lv_type.set(new abap.types.Character({length: 3}).set('str'));\n    } else if (abap.compare.eq(unique78, new abap.types.Character({length: 6}).set('number'))) {\n      lv_type.set(new abap.types.Character({length: 3}).set('num'));\n    } else if (abap.compare.eq(unique78, new abap.types.Character({length: 7}).set('boolean'))) {\n      lv_type.set(new abap.types.Character({length: 4}).set('bool'));\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: lv_type, iv_key: iv_key});\n    if (abap.compare.ne(lv_type, new abap.types.Character({length: 4}).set('null'))) {\n      if (abap.compare.eq(lv_type, new abap.types.Character({length: 3}).set('str'))) {\n        await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value, iv_value: abap.builtin.substring({val: iv_json, off: constant_1, len: abap.operators.minus(abap.builtin.strlen({val: iv_json}),constant_2)})});\n      } else {\n        await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value, iv_value: iv_json});\n      }\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: lv_type});\n  }\n  async traverse_array(INPUT) {\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let iv_key = new abap.types.String();\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_value = new abap.types.String();\n    let lv_length = new abap.types.Integer();\n    let lv_index = new abap.types.Integer();\n    let parsed = JSON.parse(iv_json.get());\n    lv_length.set(parsed.length);\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character({length: 5}).set('array'), iv_key: iv_key});\n    const unique79 = lv_length.get();\n    for (let unique80 = 0; unique80 < unique79; unique80++) {\n      abap.builtin.sy.get().index.set(unique80 + 1);\n      lv_index.set(abap.operators.minus(abap.builtin.sy.get().index,constant_1));\n      lv_value.set(JSON.stringify(parsed[lv_index.get()]));\n      await this.traverse({iv_json: lv_value});\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character({length: 5}).set('array')});\n  }\n  async traverse_object(INPUT) {\n    let iv_json = new abap.types.String();\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let iv_key = new abap.types.String();\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lt_keys = new abap.types.Table(new abap.types.String(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let lv_key = new abap.types.String();\n    let lv_value = new abap.types.String();\n    let parsed = JSON.parse(iv_json.get());\n    Object.keys(parsed).forEach(k => lt_keys.append(k));\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character({length: 6}).set('object'), iv_key: iv_key});\n    for (const unique81 of abap.statements.loop(lt_keys)) {\n      lv_key.set(unique81);\n      lv_value.set(JSON.stringify(parsed[lv_key.get()]));\n      await this.traverse({iv_json: lv_value, iv_key: lv_key});\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character({length: 6}).set('object')});\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER'] = lcl_json_parser;\nclass lcl_attribute {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_value = new abap.types.String();\n    this.if_sxml_attribute$qname = new abap.types.Structure({name: new abap.types.String()});\n    this.if_sxml_attribute$value_type = new abap.types.Integer();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    let value_type = new abap.types.Integer();\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\n    this.if_sxml_attribute$qname.get().name.set(name);\n    this.if_sxml_attribute$value_type.set(value_type);\n    this.mv_value.set(value);\n    return this;\n  }\n  async if_sxml_attribute$get_value() {\n    let value = new abap.types.String();\n    value.set(this.mv_value);\n    return value;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE'] = lcl_attribute;\nclass lcl_open_node {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_attributes = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    this.if_sxml_open_element$qname = new abap.types.Structure({name: new abap.types.String()});\n    this.if_sxml_node$type = new abap.types.Integer();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let attributes = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.attributes) {attributes.set(INPUT.attributes);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open);\n    this.if_sxml_open_element$qname.get().name.set(name);\n    this.mt_attributes.set(attributes);\n    return this;\n  }\n  async if_sxml_open_element$get_attributes() {\n    let attr = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    attr.set(this.mt_attributes);\n    return attr;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE'] = lcl_open_node;\nclass lcl_close_node {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.if_sxml_close_element$qname = new abap.types.Structure({name: new abap.types.String()});\n    this.if_sxml_node$type = new abap.types.Integer();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close);\n    this.if_sxml_close_element$qname.get().name.set(name);\n    return this;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE'] = lcl_close_node;\nclass lcl_value_node {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_value = new abap.types.String();\n    this.if_sxml_node$type = new abap.types.Integer();\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value);\n    this.mv_value.set(value);\n    return this;\n  }\n  async if_sxml_value_node$get_value() {\n    let val = new abap.types.String();\n    val.set(this.mv_value);\n    return val;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE'] = lcl_value_node;\nclass lcl_reader {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_nodes = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    this.mv_pointer = new abap.types.Integer();\n    let it_nodes = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.it_nodes) {it_nodes.set(INPUT.it_nodes);}\n    this.mt_nodes.set(it_nodes);\n    this.mv_pointer.set(constant_1);\n    return this;\n  }\n  async if_sxml_reader$read_next_node() {\n    let node = new abap.types.ABAPObject();\n    abap.statements.readTable(this.mt_nodes,{index: this.mv_pointer,into: node});\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,constant_1));\n    return node;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_READER'] = lcl_reader;\n\n__webpack_handle_async_dependencies__();\n}, 1);\n\n//# sourceURL=webpack://web/../output/cl_sxml_string_reader.clas.locals.mjs?");

/***/ })

}]);