"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkweb"] = self["webpackChunkweb"] || []).push([["output_cl_ixml_clas_locals_mjs"],{

/***/ "../output/cl_ixml.clas.locals.mjs":
/*!*****************************************!*\
  !*** ../output/cl_ixml.clas.locals.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_node_iterator\": () => (/* binding */ lcl_node_iterator),\n/* harmony export */   \"lcl_named_node_map\": () => (/* binding */ lcl_named_node_map),\n/* harmony export */   \"lcl_node_list\": () => (/* binding */ lcl_node_list),\n/* harmony export */   \"lcl_node\": () => (/* binding */ lcl_node),\n/* harmony export */   \"lcl_document\": () => (/* binding */ lcl_document),\n/* harmony export */   \"lcl_renderer\": () => (/* binding */ lcl_renderer),\n/* harmony export */   \"lcl_ostream\": () => (/* binding */ lcl_ostream),\n/* harmony export */   \"lcl_istream\": () => (/* binding */ lcl_istream),\n/* harmony export */   \"lcl_stream_factory\": () => (/* binding */ lcl_stream_factory),\n/* harmony export */   \"lcl_parser\": () => (/* binding */ lcl_parser)\n/* harmony export */ });\nconst {cx_root} = await __webpack_require__.e(/*! import() */ \"output_cx_root_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"../output/cx_root.clas.mjs\"));\n// cl_ixml.clas.locals_imp.abap\nconst constant_0 = new abap.types.Integer().set(0);\nconst constant_1 = new abap.types.Integer().set(1);\nconst constant_2 = new abap.types.Integer().set(2);\nclass lcl_node_iterator {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_pointer = new abap.types.Integer();\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let it_list = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.it_list) {it_list.set(INPUT.it_list);}\n    this.mt_list.set(it_list);\n    this.mv_pointer.set(constant_1);\n    return this;\n  }\n  async if_ixml_node_iterator$reset() {\n    this.mv_pointer.set(constant_1);\n  }\n  async if_ixml_node_iterator$get_next() {\n    let rval = new abap.types.ABAPObject();\n    abap.statements.readTable(this.mt_list,{index: this.mv_pointer,into: rval});\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,constant_1));\n    return rval;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR'] = lcl_node_iterator;\nclass lcl_named_node_map {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    return this;\n  }\n  async if_ixml_named_node_map$create_iterator() {\n    let iterator = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return iterator;\n  }\n  async if_ixml_named_node_map$get_length() {\n    let val = new abap.types.Integer();\n    val.set(abap.builtin.lines({val: this.mt_list}));\n    return val;\n  }\n  async if_ixml_named_node_map$get_named_item_ns(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let li_node = new abap.types.ABAPObject();\n    for (const unique54 of abap.statements.loop(this.mt_list)) {\n      li_node.set(unique54);\n      if (abap.compare.eq(await li_node.get().if_ixml_node$get_name(), name)) {\n        val.set(li_node);\n        return val;\n      }\n    }\n    return val;\n  }\n  async if_ixml_named_node_map$get_named_item(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_named_node_map$remove_named_item(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_named_node_map$set_named_item_ns(INPUT) {\n    let node = new abap.types.ABAPObject();\n    if (INPUT && INPUT.node) {node.set(INPUT.node);}\n    abap.statements.append({source: node, target: this.mt_list});\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP'] = lcl_named_node_map;\nclass lcl_node_list {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    return this;\n  }\n  async append(INPUT) {\n    let ii_node = new abap.types.ABAPObject();\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    abap.statements.assert(abap.compare.initial(ii_node) === false);\n    abap.statements.append({source: ii_node, target: this.mt_list});\n  }\n  async remove(INPUT) {\n    let ii_node = new abap.types.ABAPObject();\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    abap.statements.readTable(this.mt_list,{withKey: (i) => {return abap.compare.eq(i.table_line, ii_node);}});\n    if (abap.compare.eq(abap.builtin.sy.get().subrc, constant_0)) {\n      abap.statements.deleteInternal(this.mt_list,{index: abap.builtin.sy.get().tabix});\n    }\n  }\n  async if_ixml_node_list$get_length() {\n    let length = new abap.types.Integer();\n    length.set(abap.builtin.lines({val: this.mt_list}));\n    return length;\n  }\n  async if_ixml_node_list$create_iterator() {\n    let rval = new abap.types.ABAPObject();\n    rval.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR']()).constructor_({it_list: this.mt_list}));\n    return rval;\n  }\n  async if_ixml_node_list$get_item(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let index = new abap.types.Integer();\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\n    abap.statements.readTable(this.mt_list,{index: index,into: val});\n    return val;\n  }\n  async if_ixml_node_list$create_rev_iterator_filtered(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let filter = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.filter) {filter = INPUT.filter;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE_LIST'] = lcl_node_list;\nclass lcl_node {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mo_children = new abap.types.ABAPObject();\n    this.mv_name = new abap.types.String();\n    this.mv_namespace = new abap.types.String();\n    this.mv_value = new abap.types.String();\n    this.mi_parent = new abap.types.ABAPObject();\n    this.mi_attributes = new abap.types.ABAPObject();\n    let ii_parent = new abap.types.ABAPObject();\n    if (INPUT && INPUT.ii_parent) {ii_parent.set(INPUT.ii_parent);}\n    this.mo_children.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_LIST']()).constructor_());\n    this.mi_attributes.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP']()).constructor_());\n    this.mi_parent.set(ii_parent);\n    return this;\n  }\n  async if_ixml_element$get_attributes() {\n    let attr = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return attr;\n  }\n  async if_ixml_element$get_next() {\n    let next = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return next;\n  }\n  async if_ixml_element$get_name() {\n    let name = new abap.types.String();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return name;\n  }\n  async if_ixml_element$append_child(INPUT) {\n    let rc = new abap.types.Integer();\n    let new_child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return rc;\n  }\n  async if_ixml_element$clone() {\n    let val = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$create_filter_node_type(INPUT) {\n    let val = new abap.types.DataReference(new abap.types.Character({length: 4}));\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$remove_attribute_ns(INPUT) {\n    let foo = new abap.types.String();\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$create_iterator() {\n    let val = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$find_from_name_ns(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let depth = new abap.types.Integer();\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let li_iterator = new abap.types.ABAPObject();\n    let li_node = new abap.types.ABAPObject();\n    let li_children = new abap.types.ABAPObject();\n    let lt_nodes = new abap.types.Table(new abap.types.ABAPObject(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let li_top = new abap.types.ABAPObject();\n    abap.statements.append({source: this.me, target: lt_nodes});\n    for (const unique55 of abap.statements.loop(lt_nodes)) {\n      li_top.set(unique55);\n      li_children.set(await li_top.get().if_ixml_node$get_children());\n      li_iterator.set(await li_children.get().if_ixml_node_list$create_iterator());\n      let unique56 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique56++);\n        li_node.set(await li_iterator.get().if_ixml_node_iterator$get_next());\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        if (abap.compare.eq(await li_node.get().if_ixml_node$get_name(), name)) {\n          val.set(li_node);\n          return val;\n        }\n        abap.statements.append({source: li_node, target: lt_nodes});\n      }\n    }\n    return val;\n  }\n  async if_ixml_element$find_from_name(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let depth = new abap.types.Integer();\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_attribute_node(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_attribute_ns(INPUT) {\n    let val = new abap.types.String();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let li_node = new abap.types.ABAPObject();\n    li_node.set(await (await this.if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: name}));\n    if (abap.compare.initial(li_node) === false) {\n      val.set(await li_node.get().if_ixml_node$get_value());\n    }\n    return val;\n  }\n  async if_ixml_element$get_attribute(INPUT) {\n    let val = new abap.types.String();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_children() {\n    let val = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_elements_by_tag_name(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_elements_by_tag_name_ns(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_first_child() {\n    let val = new abap.types.ABAPObject();\n    val.set(await this.if_ixml_node$get_first_child());\n    return val;\n  }\n  async if_ixml_element$get_value() {\n    let val = new abap.types.String();\n    val.set(await this.if_ixml_node$get_value());\n    return val;\n  }\n  async if_ixml_element$remove_attribute(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$remove_node() {\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$render(INPUT) {\n    let ostream = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.ostream) {ostream = INPUT.ostream;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$set_attribute_node_ns(INPUT) {\n    let attr = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.attr) {attr = INPUT.attr;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$set_attribute(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$set_attribute_ns(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String();\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_element$set_value(INPUT) {\n    let rc = new abap.types.Integer();\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return rc;\n  }\n  async if_ixml_node$set_namespace_prefix(INPUT) {\n    let val = new abap.types.String();\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\n    this.mv_namespace.set(val);\n  }\n  async if_ixml_node$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    await this.mo_children.get().append({ii_node: new_child});\n  }\n  async if_ixml_node$get_attributes() {\n    let map = new abap.types.ABAPObject();\n    map.set(this.mi_attributes);\n    return map;\n  }\n  async if_ixml_node$get_first_child() {\n    let node = new abap.types.ABAPObject();\n    node.set(await this.mo_children.get().if_ixml_node_list$get_item({index: constant_1}));\n    return node;\n  }\n  async if_ixml_node$get_children() {\n    let val = new abap.types.ABAPObject();\n    val.set(this.mo_children);\n    return val;\n  }\n  async if_ixml_node$query_interface(INPUT) {\n    let foo = new abap.types.String();\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_node$remove_node() {\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_node$get_parent() {\n    let val = new abap.types.ABAPObject();\n    val.set(this.mi_parent);\n    return val;\n  }\n  async if_ixml_node$replace_child(INPUT) {\n    let new_child = new abap.types.String();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let old_child = new abap.types.String();\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_node$get_name() {\n    let val = new abap.types.String();\n    val.set(this.mv_name);\n    return val;\n  }\n  async if_ixml_node$get_depth() {\n    let val = new abap.types.Integer();\n    let li_iterator = new abap.types.ABAPObject();\n    let li_node = new abap.types.ABAPObject();\n    let lv_max = new abap.types.Integer();\n    if (abap.compare.eq(await this.mo_children.get().if_ixml_node_list$get_length(), constant_0)) {\n      val.set(constant_0);\n    } else {\n      li_iterator.set(await this.mo_children.get().if_ixml_node_list$create_iterator());\n      let unique57 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique57++);\n        li_node.set(await li_iterator.get().if_ixml_node_iterator$get_next());\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        if (abap.compare.gt(await li_node.get().if_ixml_node$get_depth(), lv_max)) {\n          lv_max.set(await li_node.get().if_ixml_node$get_depth());\n        }\n      }\n      val.set(abap.operators.add(lv_max,constant_1));\n    }\n    return val;\n  }\n  async if_ixml_node$is_leaf() {\n    let val = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    val.set(abap.builtin.boolc(abap.compare.eq(await this.mo_children.get().if_ixml_node_list$get_length(), constant_0)));\n    return val;\n  }\n  async if_ixml_node$get_namespace() {\n    let val = new abap.types.String();\n    val.set(this.mv_namespace);\n    return val;\n  }\n  async if_ixml_node$get_value() {\n    let val = new abap.types.String();\n    let li_iterator = new abap.types.ABAPObject();\n    let li_node = new abap.types.ABAPObject();\n    let lv_max = new abap.types.Integer();\n    if (abap.compare.eq(await this.mo_children.get().if_ixml_node_list$get_length(), constant_0)) {\n      val.set(this.mv_value);\n    } else {\n      li_iterator.set(await this.mo_children.get().if_ixml_node_list$create_iterator());\n      let unique58 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique58++);\n        li_node.set(await li_iterator.get().if_ixml_node_iterator$get_next());\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        val.set(val.get() + (await li_node.get().if_ixml_node$get_value()).get());\n      }\n    }\n    return val;\n  }\n  async if_ixml_node$get_type() {\n    let val = new abap.types.String();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_node$set_name(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    this.mv_name.set(name);\n  }\n  async if_ixml_node$remove_child(INPUT) {\n    let child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\n    await this.mo_children.get().remove({ii_node: child});\n  }\n  async if_ixml_node$set_value(INPUT) {\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    this.mv_value.set(value);\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE'] = lcl_node;\nclass lcl_document {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mi_node = new abap.types.ABAPObject();\n    this.mi_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n    return this;\n  }\n  async if_ixml_node$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    await this.mi_node.get().if_ixml_node$append_child({new_child: new_child});\n  }\n  async if_ixml_node$set_namespace_prefix(INPUT) {\n    let val = new abap.types.String();\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\n    await this.mi_node.get().if_ixml_node$set_namespace_prefix({val: val});\n  }\n  async if_ixml_node$get_attributes() {\n    let map = new abap.types.ABAPObject();\n    map.set(await this.mi_node.get().if_ixml_node$get_attributes());\n    return map;\n  }\n  async if_ixml_node$get_first_child() {\n    let node = new abap.types.ABAPObject();\n    node.set(await this.mi_node.get().if_ixml_node$get_first_child());\n    return node;\n  }\n  async if_ixml_node$get_children() {\n    let val = new abap.types.ABAPObject();\n    val.set(await this.mi_node.get().if_ixml_node$get_children());\n    return val;\n  }\n  async if_ixml_node$query_interface(INPUT) {\n    let foo = new abap.types.String();\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    await this.mi_node.get().if_ixml_node$query_interface({foo: foo});\n  }\n  async if_ixml_node$remove_node() {\n    await this.mi_node.get().if_ixml_node$remove_node();\n  }\n  async if_ixml_node$get_parent() {\n    let val = new abap.types.ABAPObject();\n    val.set(await this.mi_node.get().if_ixml_node$get_parent());\n    return val;\n  }\n  async if_ixml_node$replace_child(INPUT) {\n    let new_child = new abap.types.String();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let old_child = new abap.types.String();\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\n    await this.mi_node.get().if_ixml_node$replace_child({new_child: new_child, old_child: old_child});\n  }\n  async if_ixml_node$get_name() {\n    let val = new abap.types.String();\n    val.set(await this.mi_node.get().if_ixml_node$get_name());\n    return val;\n  }\n  async if_ixml_node$get_depth() {\n    let val = new abap.types.Integer();\n    val.set(await this.mi_node.get().if_ixml_node$get_depth());\n    return val;\n  }\n  async if_ixml_node$is_leaf() {\n    let val = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    val.set(await this.mi_node.get().if_ixml_node$is_leaf());\n    return val;\n  }\n  async if_ixml_node$get_namespace() {\n    let val = new abap.types.String();\n    val.set(await this.mi_node.get().if_ixml_node$get_namespace());\n    return val;\n  }\n  async if_ixml_node$get_value() {\n    let val = new abap.types.String();\n    val.set(await this.mi_node.get().if_ixml_node$get_value());\n    return val;\n  }\n  async if_ixml_node$get_type() {\n    let val = new abap.types.String();\n    val.set(await this.mi_node.get().if_ixml_node$get_type());\n    return val;\n  }\n  async if_ixml_node$set_name(INPUT) {\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    await this.mi_node.get().if_ixml_node$set_name({name: name});\n  }\n  async if_ixml_node$remove_child(INPUT) {\n    let child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\n    await this.mi_node.get().if_ixml_node$remove_child({child: child});\n  }\n  async if_ixml_node$set_value(INPUT) {\n    let value = new abap.types.String();\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    await this.mi_node.get().if_ixml_node$set_value({value: value});\n  }\n  async if_ixml_document$set_encoding(INPUT) {\n    let encoding = new abap.types.ABAPObject();\n    if (INPUT && INPUT.encoding) {encoding = INPUT.encoding;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_document$set_standalone(INPUT) {\n    let standalone = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    if (INPUT && INPUT.standalone) {standalone.set(INPUT.standalone);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_document$set_namespace_prefix(INPUT) {\n    let prefix = new abap.types.String();\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_document$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject();\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n  }\n  async if_ixml_document$get_first_child() {\n    let child = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return child;\n  }\n  async if_ixml_document$create_attribute_ns(INPUT) {\n    let element = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String();\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return element;\n  }\n  async if_ixml_document$create_element_ns(INPUT) {\n    let element = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String();\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return element;\n  }\n  async if_ixml_document$create_element(INPUT) {\n    let element = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return element;\n  }\n  async if_ixml_document$create_iterator_filtered(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let input = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.input) {input = INPUT.input;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_filter_and(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let filter1 = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.filter1) {filter1 = INPUT.filter1;}\n    let filter2 = new abap.types.Character({length: 4});\n    if (INPUT && INPUT.filter2) {filter2 = INPUT.filter2;}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_iterator() {\n    let rval = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return rval;\n  }\n  async if_ixml_document$create_filter_node_type(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let typ = new abap.types.String();\n    if (INPUT && INPUT.typ) {typ.set(INPUT.typ);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_simple_element_ns(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let parent = new abap.types.String();\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\n    let prefix = new abap.types.String();\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_filter_attribute(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_simple_element(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let parent = new abap.types.String();\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$find_from_name(INPUT) {\n    let element = new abap.types.ABAPObject();\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 35}).set('todo, use find_from_name_ns instead')));\n    return element;\n  }\n  async if_ixml_document$find_from_name_ns(INPUT) {\n    let element = new abap.types.ABAPObject();\n    let depth = new abap.types.Integer();\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    element.set(await this.mi_node.get().if_ixml_element$find_from_name_ns({name: name, depth: depth, namespace: new abap.types.Character({length: 0}).set('')}));\n    return element;\n  }\n  async if_ixml_document$find_from_path(INPUT) {\n    let val = new abap.types.ABAPObject();\n    let path = new abap.types.String();\n    if (INPUT && INPUT.path) {path.set(INPUT.path);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_elements_by_tag_name_ns(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_elements_by_tag_name(INPUT) {\n    let val = new abap.types.Character({length: 4});\n    let depth = new abap.types.Integer();\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let name = new abap.types.String();\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String();\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_root() {\n    let node = new abap.types.ABAPObject();\n    node.set(this.mi_node);\n    return node;\n  }\n  async if_ixml_document$get_root_element() {\n    let root = new abap.types.ABAPObject();\n    abap.statements.assert(abap.compare.eq(constant_1, new abap.types.Character({length: 4}).set('todo')));\n    return root;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_DOCUMENT'] = lcl_document;\nclass lcl_renderer {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n  async if_ixml_renderer$render() {\n    return;\n  }\n  async if_ixml_renderer$set_normalizing(INPUT) {\n    let normal = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    if (INPUT && INPUT.normal) {normal.set(INPUT.normal);}\n    return;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_RENDERER'] = lcl_renderer;\nclass lcl_ostream {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_OSTREAM'] = lcl_ostream;\nclass lcl_istream {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_xml = new abap.types.String();\n    let iv_xml = new abap.types.String();\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\n    this.mv_xml.set(iv_xml);\n    return this;\n  }\n  async if_ixml_istream$close() {\n    return;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_ISTREAM'] = lcl_istream;\nclass lcl_stream_factory {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n  async if_ixml_stream_factory$create_ostream_cstring(INPUT) {\n    let stream = new abap.types.ABAPObject();\n    let string = new abap.types.String();\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_OSTREAM']()).constructor_());\n    INPUT.string.set(`<?xml version=\"1.0\" encoding=\"utf-16\"?>`);\n    return stream;\n  }\n  async if_ixml_stream_factory$create_istream_string(INPUT) {\n    let stream = new abap.types.ABAPObject();\n    let xml = new abap.types.String();\n    if (INPUT && INPUT.xml) {xml.set(INPUT.xml);}\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_ISTREAM']()).constructor_({iv_xml: xml}));\n    return stream;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_STREAM_FACTORY'] = lcl_stream_factory;\nclass lcl_parser {\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mi_istream = new abap.types.ABAPObject();\n    this.mi_document = new abap.types.ABAPObject();\n    this.lc_regex_tag = lcl_parser.lc_regex_tag;\n    this.lc_regex_attr = lcl_parser.lc_regex_attr;\n    let istream = new abap.types.ABAPObject();\n    if (INPUT && INPUT.istream) {istream.set(INPUT.istream);}\n    let document = new abap.types.ABAPObject();\n    if (INPUT && INPUT.document) {document.set(INPUT.document);}\n    this.mi_istream.set(istream);\n    this.mi_document.set(document);\n    return this;\n  }\n  async if_ixml_parser$parse() {\n    let subrc = new abap.types.Integer();\n    let lv_xml = new abap.types.String();\n    let lv_offset = new abap.types.Integer();\n    let lv_value = new abap.types.String();\n    let lv_name = new abap.types.String();\n    let lv_namespace = new abap.types.String();\n    let ls_match = new abap.types.Structure({line: new abap.types.Integer(), offset: new abap.types.Integer(), length: new abap.types.Integer(), submatches: new abap.types.Table(new abap.types.Structure({offset: new abap.types.Integer(), length: new abap.types.Integer()}), {\"withHeader\":false})});\n    let ls_submatch = new abap.types.Structure({offset: new abap.types.Integer(), length: new abap.types.Integer()});\n    let lo_parent = new abap.types.ABAPObject();\n    let lo_node = new abap.types.ABAPObject();\n    lo_parent.set(await this.mi_document.get().if_ixml_document$get_root());\n    lv_xml.set(this.mi_istream.get().mv_xml);\n    abap.statements.replace(lv_xml, true, `\\n`, ``);\n    while (abap.compare.initial(lv_xml) === false) {\n      abap.statements.clear(lo_node);\n      if (abap.compare.cp(lv_xml, new abap.types.Character({length: 7}).set('<?xml *'))) {\n        abap.statements.find(lv_xml, {find: new abap.types.Character({length: 2}).set('?>'), first: true, offset: lv_offset});\n        abap.statements.assert(abap.compare.gt(lv_offset, constant_0));\n        lv_offset.set(abap.operators.add(lv_offset,constant_2));\n      } else if (abap.compare.cp(lv_xml, new abap.types.Character({length: 2}).set('<*'))) {\n        abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_tag, first: true, results: ls_match});\n        abap.statements.assert(abap.compare.eq(ls_match.get().offset, constant_0));\n        abap.statements.readTable(ls_match.get().submatches,{index: constant_1,into: ls_submatch});\n        abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, constant_0));\n        lv_name.set(lv_xml.getOffset({offset: ls_submatch.get().offset.get(), length: ls_submatch.get().length.get()}));\n        if (abap.compare.cp(lv_xml, new abap.types.Character({length: 3}).set('</*'))) {\n          lo_parent.set(await lo_parent.get().if_ixml_node$get_parent());\n        } else {\n          lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\n          if (abap.compare.ca(lv_name, new abap.types.Character({length: 1}).set(':'))) {\n            abap.statements.split({source: lv_name, at: new abap.types.Character({length: 1}).set(':'), targets: [lv_namespace,lv_name]});\n            await lo_node.get().if_ixml_node$set_namespace_prefix({val: lv_namespace});\n          }\n          await lo_node.get().if_ixml_node$set_name({name: lv_name});\n          await lo_parent.get().if_ixml_node$append_child({new_child: lo_node});\n          lo_parent.set(lo_node);\n        }\n        await this.parse_attributes({ii_node: lo_node, iv_xml: lv_xml, is_match: ls_match});\n        lv_offset.set(ls_match.get().length);\n      } else {\n        abap.statements.find(lv_xml, {find: new abap.types.Character({length: 1}).set('<'), first: true, offset: lv_offset});\n        lv_value.set(lv_xml.getOffset({length: lv_offset.get()}));\n        lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\n        await lo_node.get().if_ixml_node$set_name({name: new abap.types.Character({length: 5}).set('#text')});\n        await lo_node.get().if_ixml_node$set_value({value: lv_value});\n        await lo_parent.get().if_ixml_node$append_child({new_child: lo_node});\n      }\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset.get()}));\n      abap.statements.condense(lv_xml, {nogaps: false});\n    }\n    return subrc;\n  }\n  async parse_attributes(INPUT) {\n    let ii_node = new abap.types.ABAPObject();\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    let iv_xml = new abap.types.String();\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\n    let is_match = new abap.types.Structure({line: new abap.types.Integer(), offset: new abap.types.Integer(), length: new abap.types.Integer(), submatches: new abap.types.Table(new abap.types.Structure({offset: new abap.types.Integer(), length: new abap.types.Integer()}), {\"withHeader\":false})});\n    if (INPUT && INPUT.is_match) {is_match.set(INPUT.is_match);}\n    let ls_submatch = new abap.types.Structure({offset: new abap.types.Integer(), length: new abap.types.Integer()});\n    let lv_name = new abap.types.String();\n    let lv_value = new abap.types.String();\n    let lv_xml = new abap.types.String();\n    let li_node = new abap.types.ABAPObject();\n    let lv_offset = new abap.types.Integer();\n    let lv_length = new abap.types.Integer();\n    if (abap.compare.eq(abap.builtin.lines({val: is_match.get().submatches}), constant_1)) {\n      return;\n    }\n    lv_xml.set(iv_xml.getOffset({length: is_match.get().length.get()}));\n    let unique59 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique59++);\n      abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_attr, first: true, offset: lv_offset, length: lv_length, submatches: [lv_name,lv_value]});\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, constant_0)) {\n        return;\n      }\n      li_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n      await li_node.get().if_ixml_node$set_name({name: lv_name});\n      await li_node.get().if_ixml_node$set_value({value: lv_value});\n      await (await ii_node.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$set_named_item_ns({node: li_node});\n      lv_offset.set(abap.operators.add(lv_offset,lv_length));\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset.get()}));\n    }\n  }\n  async if_ixml_parser$set_normalizing(INPUT) {\n    let normal = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    if (INPUT && INPUT.normal) {normal.set(INPUT.normal);}\n    return;\n  }\n  async if_ixml_parser$num_errors() {\n    let errors = new abap.types.Integer();\n    return errors;\n    return errors;\n  }\n  async if_ixml_parser$add_strip_space_element() {\n    return;\n  }\n  async if_ixml_parser$get_error(INPUT) {\n    let error = new abap.types.ABAPObject();\n    let index = new abap.types.Integer();\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\n    return error;\n    return error;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_PARSER'] = lcl_parser;\nlcl_parser.lc_regex_tag = new abap.types.String();\nlcl_parser.lc_regex_tag.set('<\\\\/?([\\\\w:]+)( [\\\\w:]+=\"[\\\\w\\\\.:\\\\/]+\")*>');\nlcl_parser.lc_regex_attr = new abap.types.String();\nlcl_parser.lc_regex_attr.set('([\\\\w:]+)=\"([\\\\w\\\\.:\\\\/]+)\"');\n\n__webpack_handle_async_dependencies__();\n}, 1);\n\n//# sourceURL=webpack://web/../output/cl_ixml.clas.locals.mjs?");

/***/ })

}]);